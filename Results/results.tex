%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
% THESIS CHAPTER

\chapter[Control Architecture: Simulation Results]{Control Architecture: \\ Simulation Results}
\label{chap:results}
\ifpdf
\graphicspath{{Results/Figures/PNG/}{Results/Figures/PDF/}{Results/Figures/}}
\else
\graphicspath{{Results/Figures/EPS/}{Results/Figures/}}
\fi

\begin{figure}[H]
	\centering
	\includegraphics[width=14.5cm]{scenario_whole.png}
	\caption[The Scenario with the two robot carrying the peg and the Vision robot watching the hole]{The Scenario of the experiment. The two twin robots are carrying the peg, while the third robot is watching the hole to estimate its pose.}
	\label{fig:method_uwsim}
\end{figure}

In this Chapter, experimental set-up is described, and results are given and discussed. The code for the whole architecture is available at the following link: \url{https://github.com/torydebra/AUV-Coop-Assembly}; some details about it are discussed in section \ref{sec:controlLoop} and in appendix \ref{chap:AppendixCode}.
A video of the final experiment is visible at the following link: \url{https://streamable.com/kvoxq} (online; accessed 10-08-2019).\\

The scenario is made up of two \href{https://cirs.udg.edu/auvs-technology/auvs/girona-500-auv/}{Girona 500} I-AUV's, each one equipped with a CSIP Robot arm5E (a 4 DOF arm with a parallel yaw gripper). The final goal is to successfully coordinate the robots in such a way that the peg, hold by both manipulators, is inserted correctly in the hole, fixed in the environment. In the literature, this problem is known as \textit{peg-in-hole}.\\
One robot is equipped with a force-torque sensor that permits to understand forces applied on the peg, caused by collisions during the insertion phase. This information is provided to both robots. A third robot is equipped with two cameras to estimates the hole's pose. The figure \ref{fig:method_uwsim} shows what has just been described.\\
The chosen strategy divides the problem in two phases: Hole Detection and Insertion. In the first, preliminary steps are done to detect the hole. The third robot, not used for manipulation, is in charge of exploiting computer vision algorithms to estimate the pose of the hole. Details about this are given in section \ref{chap:vision}.
The second phase explores the problems inherent to transportation of the tool, the interaction between the peg and the hole, and the communication between the carrying agents. This is described in this Chapter.

\section{Choosing the Simulator}
\label{sec:simulators}
Some effort has been spent to choice a suitable simulator for the case. At the end, \href{http://www.irs.uji.es/uwsim/}{UWSim} [\cite{uwsim}] was chosen. It is a simulator largely used for this kind of scenarios, where underwater robots must accomplish some particular tasks. It provides a different variety of useful sensors (e.g. the used force-torque sensor and the cameras), and also personalized ones can be added. It uses ROS as the simulator interface, which makes it really easy to use. Through ROS messages, we can send commands to the robots and we can receive information from the going-on test. Contact physics is implemented using \href{https://github.com/mccdo/osgbullet}{OSGBullet} to integrate the physics engine \href{https://pybullet.org/wordpress/}{Bullet} with the 3D graphics toolkit \href{http://www.openscenegraph.org/}{OSG}. For what concerns the collisions, these are calculated taking into account the compenetration between 3D models. The more the models are compenetrated, the more the forces and torques have big magnitudes. To know further details about how the simulator is built, especially for the contact physics part, please refer to the documentation of the cited software.\\

The cons of UWSim is that the simulation is fully kinematic, so no dynamic interactions are present (expect for contact physics). This means, for example, that velocities sent to the robot are immediately accomplished, that buoyancy is not present, and that it is not simulated the physic related to the object grasping. For the scope of this thesis, this lack is not important because dynamic is not considered. Furthermore, how the collisions between the tool and the hole affect the whole manipulator chain, can be simulated thanks to the information provided by the force-torque sensor, as explained in section \ref{sec:forceConsideration}.\\

To fill the UWSIM lack of dynamics, a good alternative can be \href{https://github.com/freefloating-gazebo/freefloating_gazebo}{FreeFloatingGazebo} [\cite{freeFloatingGazebo}]. In truth, this simulator is a plug-in for Gazebo and UWSim; it integrates them in order to achieve both dynamics (thanks to Gazebo) and visually realistic I-AUV simulation (thanks to UWSim). It is easy to use as UWSim, being ROS always the adopted interface, but also because the same scene (described by an \textit{.xml} file) can be used. With this plug-in, we can simulate features as buoyancy and coupling dynamics between arm and vehicle (i.e. how arm movements affect the base).
FreeFloatingGazebo has been taken into consideration for dynamic tests, but at the end it is not used due to the lack of time. However, further works toward dynamic simulations can begin from here.\\

Another simulator is \href{http://gazebosim.org/}{Gazebo}, widely known in all robotics fields. It is the de-facto standard simulator for ROS. Due to its generic purpose, it is not a ready-to-use simulator for an underwater environment, so it can be only a starting point to develop a software specific for this particular scenario (as it is done by FreeFloatingGazebo).\\
Also other similar simulators, \href{http://www.coppeliarobotics.com/index.html}{V-REP} [\cite{vrep}] and \href{https://cyberbotics.com/}{Webots} [\cite{webots}] have been taken into consideration, but then they have been discarded for the same \enquote{not ready-to-use} reason like Gazebo.\\

Another interesting simulator is \href{https://github.com/disaster-robotics-proalertas/usv_sim_lsa}{USV} [\cite{usvsim}], a really recent and in-development project. It takes the best from UWSim, Gazebo and FreeFloatingGazebo to implement realistic simulations. However, it is focused more on surface vessels dynamics.\\

More details on these and other simulators are available in \cite{simComparisonCook} and \cite{usvsim}. From \cite{usvsim}, a schematic comparison is taken and shown in figure \ref{fig:simComparison}.
\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{simComparison.png}
	\caption[Table of Simulators Comparison]{Schematic recap of the simulation comparison taken from \cite{usvsim}. $\times$ stands for no implemented feature; ~ $\surd\,$  for a feature that is a discrete representation of the real one; ~ $\surd\surd\,$ for a good feature reproduction of the real one. More details on how each feature is evaluated are available in the original paper.}
	\label{fig:simComparison}
\end{figure}


\section{Simulating the Firm Grasp Constraint}
\label{sec:firmGrasp}
Being UWSim (introduced in section \ref{sec:simulators}) only a kinematic simulator, some additions have to be made.\\
Without dynamics, simulating correctly the peg grasping is impossible. The simulator permits to fake it with an \textit{object picker} sensor: when an object is sufficiently near to the point where this sensor is, it becomes \enquote{grasped} and, from then on, it will rigidly move with the whole robot. The problem here is that we have two robots that must take the tool, so the object can't rigidly move with both, but only with the first which catches it. \\
Furthermore, external forces applied to an object (grasped or not) can't be detected with the force-torque sensor, because, in the way it is implemented, it only detects forces acting on a vehicle part.\\

To solve this issue, a peg is modelled as an additional fixed joint attached to the end-effector of each robot. In this way, each peg is rigidly attached to its own robot. Now, the problem is how to maintain the two pegs perfectly overlapped during the whole mission, because, obviously, in real situation the tool is unique. This is also needed because the control architecture assumes a \textit{firm grasp} of the tool, without any slipping. This means that the end-effector does not move respect to the peg, and, consequently, the end-effectors of the robots do not move respect themselves. It is also important to report that the force-torque sensor does not detect collisions between the two tools, so we don't have problem for this point o view.\\

In the simulation, collisions between the \enquote{pegs} and the hole cause the tools to drive apart. This happens because collisions are propagated to the robots with a formula which use Jacobian (detailed in section \ref{sec:forceConsideration}). Jacobian derives from approximation of non-linear relationship, so results are not perfect. Thus, during the transportation, but especially during the collision propagation in the insertion phase, the two pegs distance themselves a bit. This causes that the control point for one robot is in a different position of what it expects, increasing the errors.\\

In real scenario, a firm grasp acts like a \enquote{glue}: if the end-effector tends to go away from the grasping point, friction acts to maintain it to the contact point. This is true for very small errors; if the cooperation's performance is not good, the common tool falls down or something breaks.\\

In the simulation, to fake the firm grasp, an additional routine is implemented. It simply calculates the distance between the two pegs, and it generates robot velocities to nullify this gap. It is important to notice that this is an aid that we would have also in a real scenario, as explained before. The only difference is that, in real scenario, if the errors are too big the end-effector begins to slip, and it will never return to its original grasping point. In this case, it returns always to the initial point. \\

The velocities generated by this routine are not so big to hide bad cooperation; so the tests are suitable to evaluate the proposed architecture, and to simulate real behaviours.

\section{Simulating the Collision Propagation}
\label{sec:forceConsideration}
When a robot interacts with the environment, each contact generates forces on it. Missions related to assembling any objects can't be studied in a properly manner without some considerations about these forces. In a \textit{peg-in-hole} mission, collisions between the peg and the hole will be transferred through the whole kinematic chain until the floating base, causing disturbances to the whole robotic system. Thus, it is necessary to simulate these behaviours. Being UWSim a kinematic-only simulator, an additional feature is implemented to cope with these kind of collisions.\\ 

\noindent Let us define $\boldsymbol{f} \in \mathbb{R}^3$ and $\boldsymbol{m} \in \mathbb{R}^3$ as:
\begin{equation}
\boldsymbol{f} = \begin{bmatrix}f_x \\ f_y \\ f_z\end{bmatrix} \qquad
\boldsymbol{m} = \begin{bmatrix}m_x \\ m_y \\ m_z\end{bmatrix}
\end{equation}
being $\boldsymbol{f}$ and $\boldsymbol{m}$ the resultant force and the resultant torque (projected on the tool frame $ \langle t \rangle $) of all the forces and torques acting on the tool. \\
These vectors generate a disturbance on the whole system as a velocity $ \dot{\boldsymbol{y}}_{\delta} \in \mathbb{R}^n$. This velocity can be written as [\cite{bookSiciliano}]:
\begin{equation}
	\label{eq:forTor}
	\dot{\boldsymbol{y}}_{\delta} \triangleq 
	\begin{bmatrix} \dot{\boldsymbol{q}}_{\delta} \\ \boldsymbol{v}_{1 \delta} \\ \boldsymbol{v}_{2 \delta} \end{bmatrix}
	= \begin{bmatrix} k_q \\ k_{v1} \\ k_{v2} \end{bmatrix} \, \begin{bmatrix}\;(^{lin}\boldsymbol{J}_t)^T \boldsymbol{f} + \;(^{ang}\boldsymbol{J}_t)^T \boldsymbol{m}\end{bmatrix} 
	\qquad 0 < k_q, k_{v1}, k_{v2} < 1 
\end{equation}
where $\boldsymbol{J}_t$ is the Jacobian which expresses how the Cartesian tool velocity $\dot{\boldsymbol{x}}_t$ is affected by the system velocity vector  $\dot{\boldsymbol{y}}$; $\;lin$, $ang$ superscripts refer to \textit{linear} part (top three rows) and \textit{angular} part (bottom three rows) of $\boldsymbol{J}_t$; $\;\dot{\boldsymbol{q}}_{\delta} \in \mathbb{R}^l$ are the joints velocities caused by the collisions; $\;\boldsymbol{v}_{1\delta} \in \mathbb{R}^3$ and $\boldsymbol{v}_{2\delta} \in \mathbb{R}^3$  are the linear and angular vehicle velocity caused by the collisions; $\;k_q, k_{v1}, k_{v2}$ are positive gains smaller than $1$, and in general different from each other  because we are considering different types of velocities.\\
Similarly to the Force-Torque objective (section \ref{sec:forceTask}) and for the Change Goal routine (section \ref{sec:changeGoal}), gains smaller than $1$ are necessary when dealing with forces and torques to not generate too high velocities.


\section{Experiment's assumptions}
\label{sec:expAssumption}
It is important to detail the assumptions made during the simulation. In fact, some problems, that must be taken into account in a real environment, are not explored. This is necessary due to the difficulties of the particular mission analysed. \\
So, in this section, the main assumptions are summarized.

\begin{itemize}
	\item Simulation is kinematic-only. This implies, for example, that the commanded velocity to the vehicle and the arm are accomplished \textit{instantaneously} and \textit{perfectly}. Another implication is that the movements of arm and of the vehicle don't influence each other at all. The only exceptions are the Firm Grasp constraint (section \ref{sec:firmGrasp}) and the Collision Propagation (section \ref{sec:forceConsideration}).
	
	\item The initial configuration shows the peg already grasped \textit{correctly} by both robots. Also, the point where the end-effectors have grasped the tool and the peg's dimensions are known. This implies that the relative position between each robot and peg's tip is \textit{perfectly} known.\\
	Such an initial configuration has been chosen because the grasping phase and problems arising during cooperative transportation have been explored in other projects like MARIS and ROBUST (e.g in the work \cite{IntroMaris2}) and in the on-going TWINBOT.
	
	
	\item A common reference frame (denoted as $\langle w \rangle$ - \textit{world} in the whole thesis) is used to know the relative poses among objects, carrying robots and the Vision robot. This assumption is mostly needed to make the Vision robot share correctly the estimated hole's pose.\\
	In real situation, the underwater location of something is always an issue and it is never really precise. Good precision can be provided, for example, after some preliminary works in mapping the seafloor. Another method can be the exploitation of helper support vessels, for example, as explored the WiMUST project [\cite{wimust}]. This can provide a common reference point somewhere.\\
	Please note that, for this work, it is not important that the common frame $\langle w \rangle$ is located above the sea surface. The important thing is only to have a common point, that can also be underwater.\\

	
	\item No real communication problems between the two cooperative robots are taken into account.\\
	The presence of water gives relevant issues in a real situation. A \textit{full-duplex} communication (i.e. sharing data \textit{at the same time}) is impossible. Also, in general, data exchange is much slower respect to the air. Some experiments in simulated environment with different methods of underwater communication are detailed in \cite{IntroMaris2}.\\
	However, these communication issues are considered by the cooperative scheme (as explained in section \ref{sec:coopScheme}); in fact it permits to exchange very few information between the two carrying agents.
	
	\item The two robots firmly grasp the peg. There is no sliding caused by robot movements. This point is detailed in section \ref{sec:firmGrasp}.
	
	\item During the insertion phase, the control architecture tries to resolve alignment errors \textit{only if} the peg is inside the hole. No methods are implemented to deal with the problem of \textit{looking for} the hole on the surface. So, if the peg touches the external hole surface (due to a too big hole's pose estimation error), it will bounce back and forth forever.
	
	\item The force-torque sensor is positioned on the tip of the peg, and it provides the resultant force and the resultant torque of collisions on the whole peg.\\
	This would obviously not possible in real applications. In real scenario, the sensor is usually put on the arm's wrist and it provides forces and torques respect to this point.\\
	In this case, we could have projected the force-torque sensor information on the wrist frame, to make more realistic simulation, but for simplicity this is not implemented.\\
	Furthermore, both robots have access to the sensor data, at the same frequency, and without uncertainties (except errors due to how almost all physics engines compute collisions, that it is done with approximations to improve the performance).
	
\end{itemize}

\noindent Others assumptions, more related to the vision part, are detailed in section \ref{sec:visioAssumption}.

\section{Control Loop}
\label{sec:controlLoop}
\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{flowScheme.png}	
	\caption[Flow Scheme of the Control Loop]{A flow scheme showing the main steps of a single control loop for the robots and for the coordinator. Blocks at the same horizontal level are executed at the same time. Arrows indicate sharing of data between blocks of different nodes. Note here that the Vision robot is not considered.}
	\label{fig:flowScheme}
\end{figure}

This section is written with the scope of giving a better idea on how the control architecture works.\\
The Vision robot, which job is to estimate the hole's pose, acts in a preliminary phase. It \textit{tracks} the hole, thanks to stereo-cameras, and it sends the estimated pose to the Coordinator. Due to its nature, no complicated control is implemented for this agent: when the pose is sent, we simply move the robot away from the hole with keyboard (like a ROV) to not interfere with the insertion mission. This part is described in Chapter \ref{chap:vision}.\\
After the coordinator receive the hole's pose, it sends it together with a signal to the two carrying robots to make them begin the mission.\\

The two carrying robots are fully autonomous: as soon they get the hole pose, they proceed \textit{without user intervention}. There are three nodes running at the same time: the two Robots (\textit{A} and \textit{B}) and the Coordinator. The latter is not a real \textit{physical} agent: it is only a software routine. So, it can be physically inside a robot, from now on, the Robot A. In this way, communication issues (due to the underwater scenario) occur only between the two robots, and not among all the three nodes.\\

At the beginning of the mission, the Agent A, the Agent B and the Coordinator synchronize themselves, i.e. each one waits that the other two are ready. After this phase, the normal routine starts. In figure \ref{fig:flowScheme}, the main instructions of the control loop are depicted.

\begin{itemize}
	\item At the beginning of the control loop, each node gets the updated simulation state, e.g. pose of the robots, pose of the tool, information from force-torque sensor, and so on.
	
	\item The Coordinator, which (as said previously and without loss of generality) is a software routine inside the Robot A, modifies the goal's linear position (as explained in section \ref{sec:changeGoal}), if some forces are detected. If the goal is updated, the two agents get this new information.
	
	\item In the third block's row, the Robots run the first TPIK procedure. Then, they send the necessary data to the Coordinator, which computes the cooperative velocities and sends them back to the robots. Finally, the two Agents run another two TPIK procedures, one for the cooperation (section \ref{sec:coopScheme}) and the other for the vehicle-arm coordination (section \ref{sec:armVehScheme}).
	
	\item At the end, the two Agents send the system velocity vectors provided by TPIK to the simulation.
	
	\item Before sending the velocities to the \enquote{real} simulation, some disturbances must be added to the commanded system velocity vectors. For the Robot A, this means adding effects of collisions between the peg and the hole (section \ref{sec:forceConsideration}). Instead, for the Robot B, effects of the firm grasp constraint are added (\mbox{section \ref{sec:firmGrasp}).}
	
	\item After the simulator performs a step, the loop starts again.
	
\end{itemize}

\noindent It can be noticed that the two added physical interactions (collisions and firm grasping) are added only for one robot (A and B, respectively) and not for both.\\
This is done to not add simulation errors that could occur, and that would not happen in real scenario. For example, in real situation there are not two coincident pegs (as in this simulation) and so they can't really distinguish themselves. Putting the firm grasp constraint only on one robot helps to reduce disturbances that in real scenario are not present. Also, it is sufficient to fake a real firm grasping.\\
About the collisions, they affect, \textit{directly}, only the first agent. In truth, they also affect the other one, \textit{indirectly}, because the latter is \textit{dragged} by the firm grasp constraint. So, practically, collisions affect the behaviours of both agents.\\
It is important to notice that these physical interactions do not hide control problems: if the control is setted badly, the whole mission fails (e.g. the two pegs diverge and/or compenetrate visibly with the hole).\\
%%%%

Another thing to notice is that, when the Force-Torque objective (Section \ref{sec:forceTask}) is used, both Robots need the sensor data. Being the force-torque sensor only on Robot A, this means that additional communications between Robot A and Robot B are needed. As known, underwater data transmission is complicated and slow, and its amount should be kept as small as possible (from this problem it derives the used coordination policy).\\ 

An alternative to sharing force-torque data can be using another sensor on the Robot B. The problem following this direction could be that different sensors give not exactly same data. So, the two robots run each TPIK with different information. This alternative is not explored here.\\

Another solution can be simply to avoid using this objective: this would decrease the performance of the mission (as we will see later) but results are good anyway.\\

It must be noticed that also to update the goal additional information has to be exchanged between the two robots. 

\section{Results}
\label{sec:resultNoVisio}
\begin{figure}[H]
	\centering
	\includegraphics[width=11.5cm]{scenario_onlyTwin.png}
	\vspace{5px}
	\includegraphics[width=11.5cm]{scenario_onlyTwin2.png}
	
	\caption[Scenario for tests without the vision part]{Two different points of view of the scenario for the results presented in this section. The pose estimation with vision is neglected here.}
	\label{fig:onlyTwin_uwsim}
\end{figure}
In this section, four different experiments are presented. An additional last experiment, comprehensive of the Vision part, is presented in section \ref{sec:finalTest}. Discussions and results analysis are given in section \ref{sec:resDisc}.\\ 

As said, in this section trials do not take into consideration the vision part. This is done to have a hole's pose error arbitrarily settable, that permits to discuss independently the performance of the control methods used.\\

The figure \ref{fig:onlyTwin_uwsim} shows the robots initial position. Below, some important details about the simulations are listed:
\begin{itemize}
	\item The \textbf{Peg} is a six meters long cylinder, with a diameter of 0.10 meters.
	\item The \textbf{Hole} is a cylindrical cavity with a diameter of 0.14 meters. It is at the centre of a cuboid structure. In the figure \ref{fig:onlyTwin_uwsim}, the hole is the yellow cavity between the four red circles (that are present only to aid the vision algorithms).
	\item The initial position of the agents is near the hole: the peg's tip is almost aligned perfectly to the hole, and it is at almost 0.44 meters from it.\\
	To be precise, the vector from peg's tip to the hole has components :\\ $[0.441, -0.008, -0.018]$. The peg's tip frame has the $x$-component along the length of the peg; the \mbox{$y$-component} lies on the tip's surface and it points to the left; the $z$-component points downward (as in figure \ref{fig:scenario_frames}).\\
	The orientation from the peg's tip frame to the hole frame is described by these Euler angles: $[0, 0, 1.942]$ (\textit{roll, pitch, yaw}, in degrees).
	\item The mission's aim is to drive the peg inside the hole with a depth of 0.2 meters.
	\item All the vectors displayed in the next plots are projected in the world frame (which orientation is visible in fig. \ref{fig:scenario_frames}).
\end{itemize}
\begin{figure}[H]
	\centering
	\includegraphics[width=12.5cm]{scenario_framesCrop.png}	
	\caption[Main frames of the insertion phase]{Detail of a screenshot where the main frames are drawn. The world frame is present only to clarify its orientation; its origin is not in that point. For the hole frame, the $x$-axis goes inside the cavity. The goal frame $\langle g \rangle$ has the same orientation of the hole frame, and it is shifted of 0.2 meters in the direction of hole's $x$-axis.}
	\label{fig:scenario_frames}
\end{figure}

In the following results, only a few plots (fig. \ref{fig:expWithVisioVel} and fig. \ref{fig:expWithVisioVelTool}) are related to the cooperation scheme of section \ref{sec:coopScheme}, and no long discussions are made for them. This choice has been made because no robot has difficulty in tracking the ideal common tool velocity $\dot{\boldsymbol{x}}_t\,$. So, no very interesting plot occurs when \textit{non-cooperative} and \textit{cooperative} velocities are compared. Experimental results about this particular scheme used can be found in \cite{IntroMaris2} and \cite{tesiWander}.\\

The focus of the results is on the implemented methods for helping the insertion phase: the Force-Torque objective (section \ref{sec:forceTask}) and the Change Goal routine (section \ref{sec:changeGoal}). Further outcomes are presented about the added simulation procedures: the Firm Grasp constraint (section \ref{sec:firmGrasp}) and the Collision propagation (section \ref{sec:forceConsideration}). These last two extensions are important to improve the simulation in an otherwise pure-kinematic scenario.

\subsection{Perfectly known Hole's pose}
\label{sec:testPerfectHolePose}
In the first experiment, the hole's pose (and so the goal frame $\langle g \rangle$) are known without uncertainties. The plots of figure \ref{fig:noErrorPlots} show: how the forces and the torques act on the peg; the converging positional error from the goal to the peg's tip; the tool velocities generated by the collisions; the tool velocities caused by the firm grasp constraint.

\begin{figure}[H]
	\centering
	\textbf{Perfectly known Hole's pose}\\
	\vspace{8px}
	\centerline{
		\includegraphics[width=9cm]{NOERROR/forces.eps}
		\includegraphics[width=9cm]{NOERROR/error.eps}
	}
	\vspace{6px}
	\centerline{
		\includegraphics[width=9cm]{NOERROR/collisions.eps}
		\includegraphics[width=9cm]{NOERROR/grasp.eps}
	}
	\caption[Plots with Perfectly known Hole's pose]{The results with the hole's pose known without errors. The upper left plot shows the forces and torques acting on the whole peg: they are the components of the total resultants projected on the world. The high peak in $y$ is due to the first contact between the peg and the hole surface. The upper right plot shows the convergence of the error between goal frame and tip frame. The lower left plot displays the tool velocities generated by the system motions caused by the collisions propagation. The lower right plot shows the tool velocities generated by the Firm Grasp routine.}
	\label{fig:noErrorPlots}
\end{figure}


\subsection{Error on the Hole's pose}
\label{subsec:resultsControlError}
In general, a perfect pose estimation is never achievable, so the control should take into account that errors can be present. In this experiment, an error of 0.015 meter is added along the $x$-component of the goal (considering the goal projected in the world frame). So, the peg is driven a bit on the right respect to the centre of the hole, causing a lot of collisions with the right side of the cavity.\\

Three different experiments with the given error have been conducted. In the first, the control does not use any method to exploit the force-torque data (as in the previous experiment of section \ref{sec:testPerfectHolePose}). In the second, the Change Goal routine (described in section \ref{sec:changeGoal}) is used to try to correct the pose error. In the third, both the Change Goal routine and the Force-Torque objective (described in section \ref{sec:forceTask}) are included. The addition of the new objective in the TPIK list is done to try to reduce the amount of force and torques acting on the peg.

\subsubsection{Change Goal routine results}
As explained in section \ref{sec:changeGoal}, it has been implemented a routine to move the goal's origin according to the forces and torques detected by the sensor. A comparison of the results with and without this method is visible in figure \ref{fig:Error_nothingandgoal_plot6}. It can be seen that the goal is changing, and at the end of the experiment the added error is compensated.

\subsubsection{Force-Torque objective results}
Besides changing the goal, it is useful to exploit the force-torque sensor also at kinematic level, using the provided information in the TPIK approach. The new added objective is described in section \ref{sec:forceTask}.\\
In figure \ref{fig:comparison_final} the results of the three different experiments are compared. It is visible that, when also the new objective is used, the forces and the torques have the smallest peaks. Meanwhile, the convergence of the error between the goal and the peg's tip is maintained as good as in the second experiment thanks to the presence of the same Change Goal routine.\\
In figures \ref{fig:forceTaskActRef} and \ref{fig:forceTaskVelocities} details on how this new objective works are shown. When some collisions happen, the reference and the activation grow to make the tool move in a way to reduce the force and the torque magnitudes. The figure \ref{fig:forceTaskVelocities} shows the velocities generated by the objective \textit{as if it was the only one} in the TPIK list, so they are not the real velocities given to the system.

\begin{figure} [H]
	\centering
	\textbf{Error of 0.015 meter on x-axis of the goal}\\
	\textbf{Linear and Angular component of the goal frame and the tool's tip frame}\\
\vspace{20px}
\textbf{Without Change Goal routine\\}
	\centerline{
		\includegraphics[width=22cm]{error_nothing/6_error.eps}
	}
	\vspace{15px}
\textbf{With Change Goal routine}
	\centerline{
		\includegraphics[width=22cm]{error_goal/6_error.eps}
	}
\end{figure}
\begingroup 
\captionof{figure}[Plots of Tool and Goal frames with and without changing the goal]{Results of the two experiments without and with the Change Goal routine (both without the Force-Torque objective). The plots show the pose of the goal frame $ \langle t \rangle$ and of the tool's tip frame divided into their linear and angular components. The upper six plots show results without the Change Goal routine, the bottom ones show results with the routine. All the components are respect to the world frame. For the linear part, the yellow lines represent the position of the goal without errors. The red lines represent the position of the goal that the controller uses. Please note that in some plots the red and yellow lines are coincident because the component is know without errors \emph{and} it does not change. It is clearly visible that, when the goal is modified, the red lines go toward the yellow ones, \textit{correcting} the initial hole's pose error.}
\label{fig:Error_nothingandgoal_plot6}
\endgroup



\begin{figure}[H]
	\centering
	\textbf{Error of 0.015 meter on x-axis of the goal\\}
	\vspace{30px}
	\textbf{Norm of the forces and torques acting on the peg\\}
	\vspace{10px}
	\centerline{
	\hspace{5px}
	\textbf{Without Change Goal routine} 
	\hspace{35px}
	\textbf{With Change Goal routine}
	\hspace{25px}
	\textbf{With Change Goal and Force Task} 
	}
	\centerline{ 
		\includegraphics[width=6.5cm]{error_nothing/forcesNorm.eps}
		\includegraphics[width=6.5cm]{error_goal/forceNorm.eps}
	 	\includegraphics[width=6.5cm]{error_all/forceNorm.eps}
	}
	\vspace{30px}
	\textbf{Norm of the error between ideal goal (without the added error) and tool's tip\\}
	\vspace{10px}
	\centerline{
		\hspace{5px}
		\textbf{Without Change Goal routine} 
		\hspace{35px}
		\textbf{With Change Goal routine}
		\hspace{25px}
		\textbf{With Change Goal and Force Task} 
	}
	\centerline{
		\includegraphics[width=6.5cm]{error_nothing/error.eps}
		\includegraphics[width=6.5cm]{error_goal/errorNorm.eps}
		\includegraphics[width=6.5cm]{error_all/errorNorm.eps}
	}
	\vspace{10px}
	\caption[Plots of comparisons with and without change goal and force objective]{Comparison of results of the three methods: vanilla, Change Goal and Change Goal with Force-Torque objective. The three upper plots show the norm of the force and the norm of the torque acting on the peg. It can be noticed that, in the cases where the goal is modified, at the end their norms goes to zero. The three lower plots show the norms of the error between goal and tool's tip. In the case without the Change Goal routine, the norms converge anyway, but to a slightly bigger value than the one of the other two cases. In fact, when the Change Goal routine is used, the initial hole's pose error tends to be corrected.}
	\label{fig:comparison_final}
\end{figure}

\begin{figure}[H]
	\centering
	\textbf{Error of 0.015 meter on x-axis of the goal\\}
	\textbf{with Change Goal routine and Force-Torque objective}\\
	\vspace{13px}
	\textbf{Forces and torques acting on the peg\\}
	\vspace{3px}
	\centerline{ 
		\includegraphics[width=15.5cm]{error_all/force.eps}
	}
	\vspace{10px}
	\textbf{Force-Torque objective: References and Activations\\}
	\vspace{3px}
	\centerline{
		\includegraphics[width=15.5cm]{error_all/referenceForceTask.eps}
	}
	\centerline{
		\includegraphics[width=15.5cm]{error_all/activationForceTask.eps}
	}

	\caption[Plots with reference and activation of the force task]{The forces and torques acting on the peg (above), and the corresponding generated references and activations  of the Force-Torque objective (below); they are calculated by robot A, but for robot B they are the same.}
	\label{fig:forceTaskActRef}
\end{figure}

\begin{figure}[H]
	\centering
	\textbf{Results with error of 0.015 meter on x-axis of the goal}\\
	\textbf{with Change Goal routine and Force-Torque objective}\\
	\vspace{15px}
	\textbf{Velocities generated by the Force-Torque objective only\\}
	\vspace{5px}
	\centerline{ 
		\includegraphics[width=9cm]{error_all/velocityForceTaskA.eps}
		\includegraphics[width=9cm]{error_all/velocityForceTaskB.eps}
	}
	
	\caption[Plots of the velocity command generated by the Force-Torque objective]{The velocity command generated by the Force-Torque objective, for the Robot A. These are the velocities that the task generates; the vectors depicted are simply the result of $\; \boldsymbol{J}^{\#}_{ft} \; \dot{\bar{\boldsymbol{x}}}_{ft}\;$ to show how the objective works. So they are not the real one applied to the system because with this formula higher priority objectives are not taken into consideration. For the two robots, the reference $\dot{\bar{\boldsymbol{x}}}_{ft}$ and the activation $\boldsymbol{A}_{ft}$ (visible in figure \ref{fig:forceTaskActRef}) are the same because they act with the same data; it is the Jacobian $\boldsymbol{J}^{\#}_{ft}$ which is obviously different and which makes the two plots dissimilar.}
	\label{fig:forceTaskVelocities}
\end{figure}


\section{Results with the Hole's pose estimation by Vision}
\label{sec:finalTest}
\begin{figure}[H]
	\centering
	\includegraphics[width=11cm, height=5.3cm]{uwsim_scenario_all0.png}
	\includegraphics[width=11cm, height=3.2cm]{uwsim_scenario_all1.png}
	
	\caption[Scenario for the final test with Vision]{The starting position of the robots for the final experiment, where it is used the preliminary phase to estimate the hole's pose with vision.}
	\label{fig:uwsim_expAll}
\end{figure}

In this section, results with the preliminary vision phase are presented.\\
Differently from the previous experiments of section \ref{subsec:resultsControlError}, the error of the hole's pose when using the Vision robot is not so influential on the mission. In norm, the pose estimation error is less than $0.006$ meters for the linear part and $0.01$ radians for the angular part (with the best method, as shown in figure \ref{fig:squareErrors} of section \ref{subsec:trackResult}).\\ 
However, the experiment is interesting not only because it puts all the mission phases together, but also because it shows the outcome when the error is \enquote{spread} among all linear and, especially, angular component (which was not considered before). Even more, the carrying robots start farther from the hole than before. In this simulation, both the Change Goal routine and the Force-Torque objective are used.\\
The test's details described at the beginning of section \ref{sec:resultNoVisio} are still valid, except for the initial position of the two carrying robot. This time, the distance between hole and peg's tip has component $[3.590, 0.039, -0.041]$ for the linear part (and the same as previous for the angular part: $[0, 0, 1.942]$ \textit{roll, pitch, yaw}, in degrees).\\
Some screenshots that show the main phases of the simulation are visible in figure \ref{fig:screenSimulation}. The interesting plots about the performances are shown in figure \ref{fig:expWithVisio}. To give an idea of the magnitude of the velocities involved, cooperative system velocities $\dot{\hat{\boldsymbol{y}}}_a$ and $\dot{\hat{\boldsymbol{y}}}_b\,$, and cooperative tool velocity $\dot{\tilde{\boldsymbol{x}}}_t$ are displayed in figure \ref{fig:expWithVisioVel} and figure \ref{fig:expWithVisioVelTool}. Please note that these velocities do not include the collision propagation and the firm grasp constraint, they are only the output of the kinematic layer.


\begin{figure}[H]
	\centering
	\textbf{Screenshots from the final experiment }\\
	\vspace{5px}
	\centerline{
		\includegraphics[width=6cm, height=3.5cm]{screenUWSIM/1new.png}
		\includegraphics[width=6cm, height=3.5cm]{screenUWSIM/2New.png}
	}
	\vspace{1px}
	\centerline{
		\includegraphics[width=6cm, height=3.5cm]{screenUWSIM/3.png}
		\includegraphics[width=6cm, height=3.5cm]{screenUWSIM/4.png}
	}
		\vspace{1px}
	\centerline{
		\includegraphics[width=6cm,height=3.5cm]{screenUWSIM/5.png}
		\includegraphics[width=6cm, height=3.5cm]{screenUWSIM/6.png}
	}
		\vspace{1px}
	\centerline{
		\includegraphics[width=6cm, height=3.5cm]{screenUWSIM/7.png}
		\includegraphics[width=6cm, height=3.5cm]{screenUWSIM/8.png}
	}
	\caption[Screenshots from the final experiment]{Screenshots from the final experiment with Vision. From the top to the bottom, from the left to the right: a) The Vision robot has detected the squares and it is tracking the hole's pose; b) The Vision robot is driven away and the carrying robots are ready to begin; c,d) the two robots are cooperatively transporting the peg to the hole; e) The first \enquote{contact} between the \textit{peg} and the \textit{hole}; f) The \textit{peg} is being inserted; g) The robots stop because the tool has reached the desired depth (0.2m); h) A polygon wire-frame view mode of the simulator to see the \textit{peg} inserted.}

	\label{fig:screenSimulation}
\end{figure}


\begin{figure}[H]
	\centering
	\textbf{Results with hole's pose estimation by Vision}\\
	\vspace*{20px}
	\centerline{
		\includegraphics[width=8.5cm]{withVisio/forceNorm.eps}
		\includegraphics[width=8.5cm]{withVisio/errorNorm.eps}
	}
	\vspace{30px}
	\centerline{
		\includegraphics[width=19.5cm]{withVisio/6_error.eps}
	}
	\vspace{10px}
	\caption[Plots of results with hole's pose estimation by Vision]{Results with the hole's pose estimated by the best one of the tested vision algorithms. At second 77 the peg's tip goes inside the hole (magenta vertical lines). Being the pose estimation really good, forces and torques are not so big  as in the previous tests (upper left plot). Furthermore, modification of the goal are almost not noticeable (lower plot). The positional error from goal to peg's tip  converges to a small value (upper right plot). The visible error for the angular part is due to the fact that the orientation of the goal frame has some imprecisions, due to not perfect hole's pose estimation.}
	\label{fig:expWithVisio}
\end{figure}

\begin{figure}[H]
	\centering
	\textbf{Results with hole's pose estimation by Vision}\\
	\textbf{Cooperative system velocities for robots A and B (after cooperation)}
	\vspace{20px}
	\centerline{
		\includegraphics[width=9cm]{withVisio/coopJoinVelA.eps}
		\includegraphics[width=9cm]{withVisio/coopJoinVelB.eps}
	}

	\caption[Plots of cooperative robots velocities]{The system velocities $\dot{\hat{\boldsymbol{y}}}_a$ and $\dot{\hat{\boldsymbol{y}}}_b\,$, outputs of the kinematic layer after the cooperation policy (section \ref{sec:coopScheme}) and the arm-vehicle coordination scheme (section \ref{sec:armVehScheme}). These are not always the \emph{real} robot velocities because they do not include velocities caused by collisions (for robot A) and by firm grasp constraint (for robot B).}
	\label{fig:expWithVisioVel}
\end{figure}

\begin{figure}[H]
	\centering
	\textbf{Results with hole's pose estimation by Vision}\\
	\textbf{Cooperative tool velocity (after cooperation)}
	\vspace{20px}
	\centerline{
		\includegraphics[width=12.5cm]{withVisio/coopToolVel.eps}
	}
	\caption[Plots of cooperative tool velocity]{The tool velocity $\dot{\tilde{\boldsymbol{x}}}_t$, the one that the coordinator sends to both robots during the coordination policy. It is the \emph{feasible} one that \emph{both} robots provide to the tool (section \ref{sec:coopScheme}), and it is caused by the system velocities of figure \ref{fig:expWithVisioVel}. So, it is not always the \emph{real} velocity that the tool has because collisions and firm grasp constraint are not included.}
	\label{fig:expWithVisioVelTool}
\end{figure}



\section{Results Discussion}
\label{sec:resDisc}
In this section, considerations about the results shown in the previous pages are made.\\

\subsection{Perfectly known Hole's pose discussion}
When the goal frame is known without error, the results are good even without the Force-Torque objective and the Change Goal routine.\\
This is clearly visible in figure \ref{fig:noErrorPlots}. Despite no presence of errors, some collisions happen anyway. This is due to the fact that the peg is driven  directly toward the goal (inside the hole), without considering that there is the hole structure. Anyway, the forces and torques acting on the peg \enquote{help} the insertion phase because they drive \textit{naturally} the tool inside the hole. The peaks of the magnitudes are due to the first contact with the hole: even if the pose is perfect, this does not mean that a perfect alignment is present \textit{before} reaching the goal frame.\\
 
The lower left plot of figure \ref{fig:noErrorPlots} shows the tool velocities caused by the collisions, and in the lower right one we can see that the second tool \enquote{follow} the velocities of the first one, due to the firm grasp constraint (around second 40). In other words, it is as if the robot B would be dragged by motions causes by collisions on robot A.\\
In the same plot, the chaotic velocities caused at the beginning are due to a not-perfectly coincident initial position of the two tools, that is impossible to achieve due to numerical errors of the simulation. Anyway, after a while they go to zero, so this initial error does not affect the rest of the experiment.\\

The upper right plot of figure \ref{fig:noErrorPlots} shows how the error converges along its components. The small peak in roll is caused by the initial collisions with the hole.\\

Even if a perfect goal pose is obviously impossible to have, this experiment is useful to understand how the peg is inserted if ideal conditions are present. This is important: from now we know that, in any case, the forces and torques acting on the peg may help \textit{naturally} the insertion phase.\\

\subsection{Change Goal routine discussion}
When an error in the goal pose is present, the results obviously get worse. The first noticeable thing is in figure \ref{fig:comparison_final}: due to the error the collisions are more present during the insertion (first plot). An interesting thing is that the peg is inserted at the wanted depth anyway (as can be seen in the right lower plot, where the norm converges to a small value). An issue is that the forces are not nullified at the end, which means that continuous pressure between the peg and the hole is present.\\

The first idea to reduce the number of the collisions is to introduce the routine which change the goal frame. From the plots in the middle of figure \ref{fig:comparison_final}, we see that the overall behaviour is improved: the forces and torques have a littler norm in general (upper plot) and the final position of the tool is more precise (lower plot).\\

In fact, from figure \ref{fig:Error_nothingandgoal_plot6}, the six lower plots show us that the error in $x$ is corrected by the routine. It can be noticed that also the $z$ component is modified, even if it has no initial error. This is caused by the fact that the routine is active: so, all the components are modified in the direction of the detected forces.\\
Obviously, we can't assume to have an error only along a single axis, so we can't modify only the axis where we know there is the error ($x$-axis in this case).\\
In truth, also the \mbox{$y$-component} is shifted, even if the change is very little because the component of the force acting along the length of the peg is neglected to not modify the wanted depth of insertion (as explained in \ref{sec:changeGoal}).\\

From the same figure \ref{fig:Error_nothingandgoal_plot6}, another thing to notice is that the routine does not correct perfectly the error in all the components. In fact the goal along the z-component is a bit erroneous at the end of the experiment. This happens because the peg has reached a point where the forces are zero, and so no more modifications can be done. This is caused by the fact that the peg has a smaller diameter than the hole, and so there is a tiny tolerance zone inside the cavity where collisions do not happen.\\

\subsection{Force-Torque objective discussion}
In general, the goal changes slowly: this means that, especially when the first contact happens, the forces and torques magnitudes are big as in the vanilla case.\\
The Force-Torque objective implemented helps to reduce these peaks: as soon as a force (or torque) is detected, the objective responds to it and generates a reference velocity that moves the peg away from the walls of the hole. The reduction of the magnitudes is visible in the upper plots of figure \ref{fig:comparison_final}. \\

In the lower plots of the same figure \ref{fig:comparison_final}, it is shown that the positional error between the goal and the tool is not affected so much by this objective. In fact this plot is similar to the one of the second experiment. In truth, the convergence of the norm to a small value is a bit slower than the one of the case where this objective is not used.\\
The first factor for this is that now the collisions are considered by the kinematic layer. So, being the new objective at an higher priority respect to the reaching goal objective, the kinematic control tends \textit{first} to nullify the forces and torques and \textit{then} to drive the tool toward the goal. This, sometimes, could increase the time to accomplish the mission (as in this case). Anyway, some other times it can \textit{decrease} the mission time because less stalemates happen, thanks to the fact that this objective may help to drive the peg away from the collision. In the second plot of figure \ref{fig:comparison_final}, we can see that the norm of the force stays at a nearly constant value around the interval $80s-180s$, as well as the norm of the error in the plot below. This shows a situation of stalemate that is then solved. Presence of standoffs like this one are discussed later.\\
A second factor is simply that, being the particularity of the problem, each experiment is different from the others, so sometimes the mission is \enquote{lucky} and it has less difficulties.\\

Figure \ref{fig:forceTaskActRef} shows how the new introduced objective generates references and activations in correspondence of the forces and the torques detected. Thus, obviously, the references and activations shapes (lower four plots) are similar to the forces and torques shape (upper two plots). In this case they are even more similar because the norm (which is the quantity that the objective controls) is given by almost only one component, the $y$ one.\\ 
The activation is a function which assumes only values from $0$ to $1$, so it is always positive. The reference instead, has opposite sign respect to the forces and the torques. This is because the objective wants to \textit{nullify} the forces and the torques, so it provides a velocity in the opposite direction.\\ 
In the reported plots reference and activation are the ones calculated by the \mbox{robot A}. However, the agents receive the same data from the sensor (except small synchronization problems that can happen), so the reference $\dot{\bar{\boldsymbol{x}}}_{ft}$ and the activation 	$\boldsymbol{A}_{ft}$ are the same for the robot B.\\

Figure \ref{fig:forceTaskVelocities} shows the results of $\; \boldsymbol{J}^{\#}_{ft} \; \dot{\bar{\boldsymbol{x}}}_{ft}\;$, for both robots. These are the system velocities that we would give if the Force Torque objective was the only one in the TPIK list, without considering the activation, and a simple pseudoinverse for the Jacobian was used (without any regularization). So, neither the collision propagation, the firm grasp constraint, nor the cooperation are included.\\
As explained before, the reference $\dot{\bar{\boldsymbol{x}}}_{ft}$ is the same vector for both agents. The thing that makes the two velocities so dissimilar, is the Jacobian $\boldsymbol{J}_{ft}\,$, which is obviously different for each agent because they are not in the same configuration. This difference, at this point, it is not a problem for the cooperation because we have still to deal with the coordination policy.\\
 
The plots of figure \ref{fig:forceTaskVelocities} are shown only to point out that the velocities are not so big to be not feasible. In truth, at least for the vehicle part, they could be even too small to be followed well. This can be solved making the objective to control only the arm, or by increasing the gains (but taking into account that bigger gains would mean greater risks of bad behaviours).\\
Another thing we can see is that they are not so smooth, and they have a lot of fast changes. However, firstly we have to consider that the activation, which the main work is smoothing the behaviour, is not present in the $\; \boldsymbol{J}^{\#}_{ft} \; \dot{\bar{\boldsymbol{x}}}_{ft}\;$ formula plotted.\\
Then, magnitudes are so little (in the $0.01rad/s$ order for joints, and in the $0.01m/s$ and $0.01rad/s$ order for vehicle) that these fast changes are not so important.\\
Last, we can't do so much because these changes are given by external data (the forces and the torques) that we have to deal with.\\

\subsection{Discussion about the experiment with the Vision part}
The final test of section \ref{sec:finalTest} (which includes the Vision part) is interesting for two main reasons. The first one is that the peg does not start so near the hole as in the previous trials (but it is almost aligned to it as before). So, we can see that the transportation phase is done in a good manner by the cooperative robots. This is noticeable even if no difficulties (e.g. difficult trajectories, an obstacle, a joint limit, and no vehicle and arm dynamics) are encountered.\\
The second reason is that the hole's pose has also some error on the angular components. This affect the orientation of the goal frame where the peg is driven to. Anyway, this error is small and it does not influence too much the insertion. \\

In fact, as we can see in the upper left plot of figure \ref{fig:expWithVisio}, the norm of the force and the norm of the torque are smaller than the ones of the previous experiment. Further, the error converge smoothly (upper right plot); the bigger error in the angular norm is obviously due to the fact that now there are also some imprecisions in the orientation of the hole. Also, little modifications are done to the frame goal, because its origin is almost with no error (lower plots). \\

Figure \ref{fig:expWithVisioVel} shows some plots about the cooperation. No big difficulties are met by the robots during the transportation and the insertion. So, the system velocities, that are the outputs of the final TPIK procedure (after the cooperation policy and the arm-vehicle coordination), are similar between the two robots. It must be remembered that these velocities are not the applied ones because the disturbances caused by collisions and firm grasp are not included. \\
However, for the robot B (right plot) we can see that tiny peaks are present around the interval $20s - 40s$. These can be caused \textit{indirectly} by the firm grasp constraint. When the tool of the robot B is driven away a bit, in the next control loop the kinematic layer must do a little more effort in recovering the trajectory, causing these tiny peaks. Being the cooperation policy included, if these peaks are high (as around second $8$) the robot A helps the other one, in fact a little peak is present also for the latter.\\

The last figure \ref{fig:expWithVisioVelTool} shows the \textit{feasible} \textit{cooperative} tool velocity $\dot{\tilde{\boldsymbol{x}}}_t$, that is the one that the coordinator sends to the two agents, after assuring that is achievable by both (as explained in section \ref{sec:coopScheme}).\\
The \textit{non-cooperative} velocities $\dot{\boldsymbol{x}}_{t,a}$ and $\dot{\boldsymbol{x}}_{t,b}\,$ are not shown because they are very similar to the cooperative one. This is caused by the fact that no robot has difficulties in providing the \textit{ideal} tool velocity.\\
Even if disturbances of collisions and of firm grasp constraint are not present, this plot gives an idea about the tool's speed during the mission. The object is driven slowly because the mission needs so: the insertion phase, made by two kinematic cooperative manipulators, puts big challenges and we can't afford to have too big gains.\\

\subsection{Standoff discussion}
A last thing to report is that some experiments meet a standoff situation at some point during the insertion. This happens when the collisions continuously make the peg to \enquote{bounce} on the inner hole walls, making it moving back and forth. The \enquote{bounce} is due to a bad peg alignment inside the hole, so the tip continuously touches the inner wall.\\

In these cases, sometimes, the methods used do not manage to solve the stalemate in a reasonable time. The problem can be due to different factors.\\
One could be that the simulation, being only kinematic, is not precise. So, even if the gains are really small, in any case the velocities are instantaneously provided to the system, which causes always a bit of chattering. This complicates the work of the simulator (to calculate the collisions) and of the whole mission (that could meet almost instantaneously a strong force or torque).\\
Another problem could be a not so good setting of the many gains that we have to put.\\ Other one can be given by how Collision Propagation work. Collisions propagate on the system through Jacobians, that are mappings derived from linear approximations of non-linear things.\\ 
Other one can be that, with the Change Goal routine, orientation's modifications are not made, so no corrections are doable for the angular part.\\
Additional problem to take into account is that some synchronization issues may happen. The coordination policy, in the way it is implemented, assures the synchronization (section \ref{sec:controlLoop}), but we have also other kinds of exchanged information. For example, the force-torque sensor data is shared using ROS topics in a simple way, so with the actual software we can't know exactly when information arrives to each node. Considering also that on a single machine we run the simulation and the two robot software (plus the coordinator) this could cause even more synchronization problems. This may be solved with further code improvement, but it would go out of the scope of this work and, also, it would not be so useful for the real application (where we don't run everything on a single machine).\\

The standoff problem is more influential when the hole's pose error is bigger, or, for example, when we have also orientation error such as in the last experiment. However, the methods show a good starting point to improve the current state of the art in this unexplored problem underwater.
